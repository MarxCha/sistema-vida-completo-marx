// src/modules/pup/pup.service.ts
import { PrismaClient, PatientProfile, DocumentCategory } from '@prisma/client';
import { v4 as uuidv4 } from 'uuid';
import { encrypt, decrypt, encryptJSON, decryptJSON } from '../../common/utils/encryption';
import { generateEmergencyQR } from '../../common/utils/qr-generator';
import { pdfGeneratorService, MedicalProfileData } from '../../common/services/pdf-generator.service';
import { s3Service } from '../../common/services/s3.service';
import { logger } from '../../common/services/logger.service';

const prisma = new PrismaClient();

// Tipos para datos médicos (descifrados)
interface MedicalData {
  allergies: string[];
  conditions: string[];
  medications: string[];
}

interface DonorPreferences {
  organs: string[];
  tissues: string[];
  forResearch: boolean;
  restrictions?: string;
}

interface ProfileInput {
  bloodType?: string;
  allergies?: string[];
  conditions?: string[];
  medications?: string[];
  insuranceProvider?: string;
  insurancePolicy?: string;
  insurancePhone?: string;
  isDonor?: boolean;
  donorPreferences?: DonorPreferences;
}

interface ProfileResponse {
  id: string;
  bloodType: string | null;
  allergies: string[];
  conditions: string[];
  medications: string[];
  insuranceProvider: string | null;
  insurancePolicy: string | null;
  insurancePhone: string | null;
  isDonor: boolean;
  donorPreferences: DonorPreferences | null;
  photoUrl: string | null;
  qrToken: string;
}

class PupService {
  /**
   * Obtiene el perfil del paciente (descifrado)
   */
  async getProfile(userId: string): Promise<ProfileResponse | null> {
    const profile = await prisma.patientProfile.findUnique({
      where: { userId },
    });

    if (!profile) {
      return null;
    }

    return this.decryptProfile(profile);
  }

  /**
   * Actualiza el perfil del paciente (crea si no existe)
   */
  async updateProfile(userId: string, input: ProfileInput): Promise<ProfileResponse> {
    // Cifrar datos sensibles
    const updateData: any = {};

    if (input.bloodType !== undefined) {
      updateData.bloodType = input.bloodType;
    }

    if (input.allergies !== undefined) {
      updateData.allergiesEnc = encryptJSON(input.allergies);
    }

    if (input.conditions !== undefined) {
      updateData.conditionsEnc = encryptJSON(input.conditions);
    }

    if (input.medications !== undefined) {
      updateData.medicationsEnc = encryptJSON(input.medications);
    }

    if (input.insuranceProvider !== undefined) {
      updateData.insuranceProvider = input.insuranceProvider;
    }

    if (input.insurancePolicy !== undefined) {
      updateData.insurancePolicy = input.insurancePolicy;
    }

    if (input.insurancePhone !== undefined) {
      updateData.insurancePhone = input.insurancePhone;
    }

    if (input.isDonor !== undefined) {
      updateData.isDonor = input.isDonor;
    }

    if (input.donorPreferences !== undefined) {
      updateData.donorPreferencesEnc = encryptJSON(input.donorPreferences);
    }

    // Usar upsert para crear el perfil si no existe
    const profile = await prisma.patientProfile.upsert({
      where: { userId },
      update: updateData,
      create: {
        userId,
        ...updateData,
        // Generar QR token si es un perfil nuevo
        qrToken: uuidv4(),
      },
    });

    return this.decryptProfile(profile);
  }

  /**
   * Actualiza la foto de perfil
   */
  async updatePhoto(userId: string, photoUrl: string): Promise<ProfileResponse> {
    const profile = await prisma.patientProfile.update({
      where: { userId },
      data: { photoUrl },
    });

    return this.decryptProfile(profile);
  }

  /**
   * Regenera el código QR
   */
  async regenerateQR(userId: string): Promise<{ qrToken: string; qrDataUrl: string }> {
    const newQrToken = uuidv4();

    await prisma.patientProfile.update({
      where: { userId },
      data: {
        qrToken: newQrToken,
        qrGeneratedAt: new Date(),
      },
    });

    const qrResult = await generateEmergencyQR(newQrToken);

    return {
      qrToken: newQrToken,
      qrDataUrl: qrResult.qrDataUrl,
    };
  }

  /**
   * Obtiene el código QR del usuario (crea perfil si no existe)
   */
  async getQR(userId: string): Promise<{ qrToken: string; qrDataUrl: string; generatedAt: Date }> {
    // Buscar perfil existente
    let profile = await prisma.patientProfile.findUnique({
      where: { userId },
      select: { qrToken: true, qrGeneratedAt: true },
    });

    // Si no existe perfil, crear uno básico con QR
    if (!profile) {
      const qrToken = uuidv4();
      const now = new Date();

      profile = await prisma.patientProfile.create({
        data: {
          userId,
          qrToken,
          qrGeneratedAt: now,
        },
        select: { qrToken: true, qrGeneratedAt: true },
      });

      logger.info('Perfil básico creado automáticamente para QR', { userId });
    }

    const qrResult = await generateEmergencyQR(profile.qrToken);

    return {
      qrToken: profile.qrToken,
      qrDataUrl: qrResult.qrDataUrl,
      generatedAt: profile.qrGeneratedAt,
    };
  }

  /**
   * Obtiene perfil por QR token (para acceso de emergencia)
   * Solo retorna datos críticos
   */
  async getProfileByQRToken(qrToken: string): Promise<{
    userId: string;
    name: string;
    dateOfBirth: Date | null;
    sex: string | null;
    bloodType: string | null;
    allergies: string[];
    conditions: string[];
    medications: string[];
    isDonor: boolean;
    photoUrl: string | null;
  } | null> {
    const profile = await prisma.patientProfile.findUnique({
      where: { qrToken },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            dateOfBirth: true,
            sex: true,
          },
        },
      },
    });

    if (!profile) {
      return null;
    }

    return {
      userId: profile.user.id,
      name: profile.user.name,
      dateOfBirth: profile.user.dateOfBirth,
      sex: profile.user.sex,
      bloodType: profile.bloodType,
      allergies: profile.allergiesEnc ? decryptJSON<string[]>(profile.allergiesEnc) : [],
      conditions: profile.conditionsEnc ? decryptJSON<string[]>(profile.conditionsEnc) : [],
      medications: profile.medicationsEnc ? decryptJSON<string[]>(profile.medicationsEnc) : [],
      isDonor: profile.isDonor,
      photoUrl: profile.photoUrl,
    };
  }

  /**
   * Descifra un perfil de la base de datos
   */
  private decryptProfile(profile: PatientProfile): ProfileResponse {
    // Función helper para desencriptar con manejo de errores
    const safeDecryptJSON = <T>(encryptedData: string | null, defaultValue: T): T => {
      if (!encryptedData) return defaultValue;
      try {
        return decryptJSON<T>(encryptedData);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        logger.error('Error desencriptando datos del perfil:', {
          error: errorMessage,
          profileId: profile.id,
          field: 'unknown'
        });
        // Retornar valor por defecto si hay error de desencriptación
        return defaultValue;
      }
    };

    return {
      id: profile.id,
      bloodType: profile.bloodType,
      allergies: safeDecryptJSON<string[]>(profile.allergiesEnc, []),
      conditions: safeDecryptJSON<string[]>(profile.conditionsEnc, []),
      medications: safeDecryptJSON<string[]>(profile.medicationsEnc, []),
      insuranceProvider: profile.insuranceProvider,
      insurancePolicy: profile.insurancePolicy,
      insurancePhone: profile.insurancePhone,
      isDonor: profile.isDonor,
      donorPreferences: safeDecryptJSON<DonorPreferences | null>(profile.donorPreferencesEnc, null),
      photoUrl: profile.photoUrl,
      qrToken: profile.qrToken,
    };
  }

  /**
   * Genera el documento PDF del perfil médico y lo guarda en documentos
   */
  async generateProfileDocument(userId: string): Promise<{ documentId: string; title: string } | null> {
    try {
      // Obtener datos del usuario
      logger.info('Iniciando proceso de generación de PDF para usuario', { userId });

      const user = await prisma.user.findUnique({
        where: { id: userId },
        select: {
          id: true,
          name: true,
          email: true,
          phone: true,
          curp: true,
          dateOfBirth: true,
        },
      });

      if (!user) {
        logger.error('Usuario no encontrado para generar PDF', { userId });
        throw new Error('Usuario no encontrado');
      }
      logger.info('Usuario encontrado', { userName: user.name });

      // Obtener perfil médico
      const profile = await prisma.patientProfile.findUnique({
        where: { userId },
      });

      if (!profile) {
        logger.error('Perfil no encontrado para generar PDF', { userId });
        throw new Error('Perfil médico no configurado');
      }
      logger.info('Perfil médico encontrado, procediendo a descifrar datos');

      // Obtener representantes
      const representatives = await prisma.representative.findMany({
        where: { userId },
        orderBy: { priority: 'asc' },
      });

      // Preparar datos para el PDF
      let medicalData;
      try {
        medicalData = {
          allergies: profile.allergiesEnc
            ? decryptJSON<Array<{ name: string; severity: string; reaction?: string }>>(profile.allergiesEnc)
            : undefined,
          medications: profile.medicationsEnc
            ? decryptJSON<Array<{ name: string; dose: string; frequency: string; reason?: string }>>(profile.medicationsEnc)
            : undefined,
          conditions: profile.conditionsEnc
            ? decryptJSON<Array<{ name: string; diagnosisDate?: string; status?: string }>>(profile.conditionsEnc)
            : undefined,
        };
      } catch (decryptError: any) {
        logger.error('Error crítico descifrando datos del perfil médico. ¿La ENCRYPTION_KEY es correcta?', {
          userId,
          errorMessage: decryptError.message
        });
        throw new Error(`Decryption Error: Falló el descifrado de datos médicos. Verifique la clave de cifrado del servidor. (${decryptError.message})`);
      }

      const profileData: MedicalProfileData = {
        user: {
          name: user.name,
          email: user.email,
          phone: user.phone || '',
          curp: user.curp || '',
          birthDate: user.dateOfBirth || undefined,
        },
        profile: {
          bloodType: profile.bloodType || '',
          qrToken: profile.qrToken,
          photoUrl: profile.photoUrl || '',
          insuranceProvider: profile.insuranceProvider || '',
          insurancePolicy: profile.insurancePolicy || '',
          insurancePhone: profile.insurancePhone || '',
          isDonor: profile.isDonor,
          donorPreferences: profile.donorPreferencesEnc
            ? decryptJSON<DonorPreferences>(profile.donorPreferencesEnc)
            : undefined,
          ...medicalData
        },
        representatives: representatives.map(rep => ({
          name: rep.name,
          relationship: rep.relation,
          phone: rep.phone,
          email: rep.email || undefined,
          isPrimary: rep.priority === 1,
        })),
      };

      logger.info('Enviando datos al motor de PDF (Puppeteer)...');
      const startTime = Date.now();
      const pdfBuffer = await pdfGeneratorService.generateMedicalProfilePDF(profileData);
      const generationTime = Date.now() - startTime;
      logger.info(`PDF generado en ${generationTime}ms`, { size: pdfBuffer.length });

      const documentTitle = 'Perfil Médico de Emergencia';
      const fileName = `perfil-medico-${user.name.toLowerCase().replace(/\s+/g, '-')}.pdf`;

      // Buscar si ya existe un documento de perfil médico
      const existingDoc = await prisma.medicalDocument.findFirst({
        where: {
          userId,
          title: documentTitle,
          category: 'CLINICAL_HISTORY' as DocumentCategory,
        },
      });

      let documentId: string;

      // Subir PDF a S3
      const uploadResult = await s3Service.uploadFile({
        buffer: pdfBuffer,
        fileName: fileName,
        mimeType: 'application/pdf',
        folder: `documents/${userId}`,
      });

      const { url: fileUrl, key: s3Key } = uploadResult;

      if (existingDoc) {
        // Actualizar documento existente
        documentId = existingDoc.id;

        // Eliminar archivo anterior de S3 si es diferente
        if (existingDoc.s3Key !== s3Key) {
          await s3Service.deleteFile(existingDoc.s3Key).catch(() => { });
        }

        await prisma.medicalDocument.update({
          where: { id: existingDoc.id },
          data: {
            fileUrl,
            s3Key,
            fileSize: pdfBuffer.length,
            updatedAt: new Date(),
          },
        });

        logger.info('Documento de perfil médico actualizado', { userId, documentId });
      } else {
        // Crear nuevo documento
        documentId = uuidv4();

        await prisma.medicalDocument.create({
          data: {
            id: documentId,
            userId,
            title: documentTitle,
            description: 'Documento generado automáticamente con la información de tu perfil médico de emergencia. Se actualiza cada vez que modificas tu perfil.',
            category: 'CLINICAL_HISTORY' as DocumentCategory,
            fileName,
            fileType: 'application/pdf',
            fileSize: pdfBuffer.length,
            fileUrl,
            s3Key,
            isVisible: true, // Visible en emergencias
            documentDate: new Date(),
          },
        });

        logger.info('Documento de perfil médico creado', { userId, documentId });
      }

      return { documentId, title: documentTitle };
    } catch (error: any) {
      logger.error('Error generando documento de perfil médico', {
        userId,
        errorMessage: error?.message,
        errorStack: error?.stack,
      });
      throw error;
    }
  }
}

export const pupService = new PupService();
export default pupService;
